package de.kalass.agime.ml;

import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;

import org.ejml.simple.SimpleMatrix;
import org.joda.time.LocalTime;

import java.util.Collection;
import java.util.List;

import de.kalass.agime.prediction.PredictionData;
import de.kalass.commons.ml.MultiClassPrediction;

/**
 * Serializer for Models generated by ActivityTypeByStartTimeModel
 *
 * Created by klas on 08.04.14.
 */
public class PredictionSerializer {

    public static PredictionData.ActivityPredictionData toProtobuf(
            ActivityTypeByStartTimeModel model
    ) {
        ActivityTypeByStartTimeModel.RowBuilder rowBuilder = model.getRowBuilder();
        MultiClassPrediction<Long> multiClassPrediction = model.getInternalModel();
        PredictionData.ActivityPredictionRowBuilderState.Builder rbb = PredictionData.ActivityPredictionRowBuilderState.newBuilder();
        rbb.setNumDimensions(rowBuilder.getNumDimensions());
        rbb.setNumPrevious(rowBuilder.getNumPrevious());
        rbb.setWeekdaysFieldsNum(rowBuilder.getWeekdayFieldsNum());
        for (LocalTime border: rowBuilder.getTimeSliceBorders()) {
            PredictionData.LocalTime.Builder builder = PredictionData.LocalTime.newBuilder();
            builder.setHour(border.getHourOfDay()).setMinute(border.getMinuteOfHour());
            rbb.addTimeSliceBorders(builder);
        }

        for (long activityTypeId: rowBuilder.getActivityTypeIdsArray()) {
            rbb.addActivityTypeId(activityTypeId);
        }

        PredictionData.MulticlassLogisticRegression.Builder mcl = PredictionData.MulticlassLogisticRegression.newBuilder();

        for (MultiClassPrediction.InputItem<Long> fkt: multiClassPrediction.getProbabilityFunctions()) {
            SimpleMatrix theta = fkt.getTheta();
            Preconditions.checkState(theta.numCols() == 1);
            PredictionData.LogisticRegression.Builder thetasBuilder =PredictionData.LogisticRegression.newBuilder();

            for (int i = 0; i < theta.numRows(); i++) {
                thetasBuilder.addTheta(theta.get(i, 0));
            }
            Long classValue = fkt.getClassValue();
            thetasBuilder.setSerializedClassValue(classValue == null ? null : classValue.toString());
            mcl.addThetas(thetasBuilder);
        }

        for (double mean: multiClassPrediction.getMeans()) {
            mcl.addMeansPerColumn(mean);
        }
        for (double stdDev: multiClassPrediction.getStdDevs()) {
            mcl.addStdDevPerColumn(stdDev);
        }



        return PredictionData.ActivityPredictionData.newBuilder()
                .setRowBuilder(rbb)
                .setTrainingResult(mcl)
                .build();
    }

    public static ActivityTypeByStartTimeModel fromProtobuf(PredictionData.ActivityPredictionData input) {
        MultiClassPrediction<Long> prediction = getPrediction(input.getTrainingResult());
        ActivityTypeByStartTimeModel.RowBuilder rowBuilder = getRowBuilder(input.getRowBuilder());
        return ActivityTypeByStartTimeModel.restore(prediction, rowBuilder);
    }

    private static MultiClassPrediction<Long> getPrediction(final PredictionData.MulticlassLogisticRegression trainingResult) {
        final Collection<MultiClassPrediction.InputItem<Long>> probabilityFunctions = getProbabilityFunctions(trainingResult.getThetasList());
        double[] means = asDoubleArray(trainingResult.getMeansPerColumnList());
        double[] stdDevs = asDoubleArray(trainingResult.getStdDevPerColumnList());
        return new MultiClassPrediction<Long>(probabilityFunctions, means, stdDevs);
    }

    private static Collection<MultiClassPrediction.InputItem<Long>> getProbabilityFunctions(
            final List<PredictionData.LogisticRegression> thetasList
    ) {
        ImmutableList.Builder<MultiClassPrediction.InputItem<Long>> r = ImmutableList.builder();
        for (PredictionData.LogisticRegression lr: thetasList) {
            String sv = lr.getSerializedClassValue();
            Long classValue = Long.parseLong(sv, 10);
            SimpleMatrix thetas = new SimpleMatrix(lr.getThetaCount(), 1);
            for (int i = 0; i < lr.getThetaCount(); i++) {
                thetas.set(i, 0, lr.getTheta(i));
            }
            r.add(new MultiClassPrediction.InputItem<Long>(classValue, thetas));
        }
        return r.build();
    }

    private static double[] asDoubleArray(final List<Double> doubles) {
        double[] r = new double[doubles.size()];
        for (int i = 0; i < doubles.size(); i++) {
            r[i] = doubles.get(i);
        }
        return r;
    }

    private static long[] asLongArray(final List<Long> longs) {
        long[] r = new long[longs.size()];
        for (int i = 0; i < longs.size(); i++) {
            r[i] = longs.get(i);
        }
        return r;
    }


    private static ActivityTypeByStartTimeModel.RowBuilder getRowBuilder(final PredictionData.ActivityPredictionRowBuilderState rowBuilder) {
        int weekdayFieldsNum = rowBuilder.getWeekdaysFieldsNum();
        int numPrevious = rowBuilder.getNumPrevious();
        ActivityTypeByStartTimeModel.RowBuilder r = new ActivityTypeByStartTimeModel.RowBuilder(
                weekdayFieldsNum, numPrevious, getTimeSliceBorders(rowBuilder),
                asLongArray(rowBuilder.getActivityTypeIdList())
        );
        if (rowBuilder.getNumDimensions() != r.getNumDimensions()) {
            throw new IllegalStateException("Original row builder had " + rowBuilder.getNumDimensions() + " dimensions, new builder has " + r.getNumDimensions());
        }
        return r;
    }

    private static ImmutableList<LocalTime> getTimeSliceBorders(final PredictionData.ActivityPredictionRowBuilderState rowBuilder) {
        ImmutableList.Builder<LocalTime> timeSliceBorders = ImmutableList.builder();

        for (PredictionData.LocalTime lt: rowBuilder.getTimeSliceBordersList()) {
            timeSliceBorders.add(new LocalTime(lt.getHour(), lt.getMinute()));
        }
        return timeSliceBorders.build();
    }
}
